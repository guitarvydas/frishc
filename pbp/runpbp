#!/bin/bash

# use a pbp multi-language tool to build a part of the current project
# $1 = the tool, often "./pbp/dtree/dtree-transmogrifier"
# $2 = path to pbp tools (often "./pbp")
# $3 = command line arg passed to the $1 tool ; if $3 is a valid file, then it is fully qualified, else no change

# env vars that can be used by spawned scripts:
## PBP_WD    is the path to the current project that is using a given PBP APP (e.g. pwd)
## PBP_LIBD  is the path to the pbp tools (often "./pbp")
## PBP_APPD  is the path to the pbp-based tool that is being used by the APP
#
## PBP_t2t           - t2t (text to text transmogrifier) tool
## PBP_das2json      - das2json tool (drawing (drawio) to JSON converter)
## PBP_splitoutputs  - output splitter - takes output from PBP and creates one 'out.??' file per stream
## PBP_dtree         - decision tree diagram to .py/.js transmogrifier
#
## PBP_arg - argument passed to the pbp-based APP, fully qualified if it's a valid filename 

# Quit immediately if there are any errors
set -e

# Variable assignments (uppercase = exported, lowercase = local)
export PBP_WD="$(pwd)"
export PBP_LIBD="$(python -c "import os, sys; print(os.path.abspath(sys.argv[1]))" "$2")"
export PBP_APPD="$(python -c "import os, sys; print(os.path.abspath(sys.argv[1]))" "$1")"
app_main="${PBP_APPD}.drawio"

# PBP arg: third parameter as full path if it's a file, otherwise just the parameter
if [[ -f "$3" ]]; then
    export PBP_arg="$(python -c "import os, sys; print(os.path.abspath(sys.argv[1]))" "$3")"
else
    export PBP_arg="$3"
fi

export PBP_t2t="${PBP_LIBD}/t2t.sh"
export PBP_das2json="${PBP_LIBD}/das2json.sh"
export PBP_split_outputs="${PBP_LIBD}/splitoutputs.sh"
export PBP_check_for_errors="${PBP_LIBD}/check-for-errors.sh"

# Push kernel onto PYTHONPATH
export PYTHONPATH="${PBP_LIBD}/kernel:${PYTHONPATH}"

# Change to the app directory
cd "${PBP_APPD}"

# Remove all 'out.*' files
rm -f out.*

# Run das2json on app main
"${PBP_das2json}" "${app_main}"

# Run check for errors on app main.json
"${PBP_check_for_errors}" "${app_main}.json"

# Run python and pipe to split outputs
python main.py "${PBP_LIBD}" "${PBP_arg}" main "${PBP_arg}.json" | "${PBP_split_outputs}"

# Check if the run produced "out.✗"
if [[ -f "out.✗" ]]; then
    mv "out.✗" "ERRORS"
    cat "ERRORS"
    exit 1
else
    # Get basename of PBP_arg for output filenames
    arg_basename="$(basename "${PBP_arg}")"
    
    # Move output files to original working directory with renamed filenames
    mv "out.frish" "${PBP_WD}/${arg_basename}.frish"
    mv "out.dt" "${PBP_WD}/${arg_basename}.dt"
    mv "out.js" "${PBP_WD}/${arg_basename}.js"
    mv "out.py" "${PBP_WD}/${arg_basename}.py"
fi

